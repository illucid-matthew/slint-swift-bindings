# Slint bindings for Swift

Attempt at creating bindings for Slint in Swift, re-using the private FFI interface meant for the C++ bindings.

__Status__: üöß _Under construction_.

I'm able to build and link an application, and can call the private API from Swift.

Next up I guess is to implement the tests from the C++ bindings, and make them function.

## Building/Running

To build the example, run:

    $ mkdir build && cd build
    $ cmake .. -GNinja
    $ cmake --build .
    $ ./Example/Example

You should then see:

    Hello from the Swift application üèóÔ∏è!
    Hello from the Swift library! üî®
    Setting up timer ‚è∞ (random value: 28)
    Starting event loop üîÅ

And then it will hang for 5 seconds. Then, you'll see:

    Called from event loop üëç (random value: 28)
    Done! ü§ì


## Structure

- `Bridging/`
    - `FFI.h`: Umbrella header that imports Slint's private FFI.
    - `Slint.modulemap`: Module map, so Swift can import the Slint library.
    - `Slint-overlay.yaml`: The module map and bridging header are overlaid instead of copied into `slint-cpp`.
- `Sources/`
    - `Slint.swift`: Nexus point of the library.
    - `‚Ä¶.swift`: Slint bindings, providing a marginally nicer API.
- `Tests/`
    - Currently under construction. Does not yet work.
- `Example/`
    - Small example application. Just used for development.

## How It's Made

- The C++ library is built following the example Slint C++ template.
- A module map and bridging header is overlaid where Slint was built.
- The modulemap allows Swift to import Slint's FFI as `SlintFFI`.
- A Swift library CMake target is created, linking to Slint.
- Applications can link to that library.

Note that Swift won't import functions or types that are marked `extern "C"` when in C++ interop mode.
They must be bridged to C++ in a header before they are accessible.

## The FFI

The FFI interface is generated by the `cbindgen`, which analyzes the Slint crates to find things to bridge.

From the C++ binding's CMake file to the FFI:
1. The CMake lists pulls in `corrosion`, which gives CMake access to Rust crates.
2. `corrosion` pulls in the `slint-cpp` crate.
3. The `slint-cpp` crate pulls in the core Slint crates and `cbindgen`.
4. The `slint-cpp` build script `build.rs` creates directories for generated headers, and calls `cbindgen::gen_all()`.
5. `gen_all()` is defined in `cbindgen.rs`. It generates the headers for an FFI interface.

The items that are generated by `gen_all()` are, in order:
1. Enumerations

    There doesn't appear to be any issues with these.

2. Built-in Structs

    Some of these reference `SharedString`, and it is forward declared in `slint_string_internal.h`.
    This type is defined in Rust, but is excluded from being exported by `cbindgen`.
    The C++ bindings provide an implemenatation.

3. Core Library

    The set of types needed for the Slint runtime are explicitly listed here.
    Another list of types to exclude are here, including `SharedString` and `SharedVector`.

    The files generated are, in order:

    1. `slint_string_internal.h`
    2. `slint_sharedvector_internal.h`
    3. `slint_properties_internal.h`
    4. `slint_timer_internal.h`
    5. Using many of the graphics Rust files, but a different config to pull in specific things:
        1. `slint_image_internal.h`
        2. `slint_color_internal.h`
        3. `slint_pathdata_internal.h`
        4. `slint_brush_internal.h`
    6. `slint_generated_public.h`
    7. `slint_internal.h`

4. Qt Backend

    Has a list of items to export, and automatically pulls in anything else required.

5. Platform

    This one is interesting.
    Instead of working from within Slint's crates, it instead generates a header for `platform.rs` in the `api/cpp` directory.
    The very same one that `cbindgen.rs` is located in.

6. _If enabled,_ Interpreter

    Excludes some common types and specific items, and then picks up everything in the `internal/interpreter` crate.

## Resources

- [Swift: Mixing Swift and C++](https://www.swift.org/documentation/cxx-interop/)
- [Swift: Mixing Swift and C++ Using Other Build Systems](https://www.swift.org/documentation/cxx-interop/project-build-setup/#mixing-swift-and-c-using-other-build-systems)
- [Swift: Wrapping C/C++ Library in Swift](https://www.swift.org/documentation/articles/wrapping-c-cpp-library-in-swift.html)
- [GitHub: apple/swift-cmake-examples](https://github.com/apple/swift-cmake-examples/tree/main/3_bidirectional_cxx_interop)
- [Github: slint-ui/slint-cpp-template](https://github.com/slint-ui/slint-cpp-template/blob/main/CMakeLists.txt)
